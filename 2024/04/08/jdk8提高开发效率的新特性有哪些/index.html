

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Wick">
  <meta name="keywords" content="">
  
    <meta name="description" content="jdk8以上提高开发效率的新特性有哪些">
<meta property="og:type" content="article">
<meta property="og:title" content="jdk8以上提高开发效率的新特性有哪些">
<meta property="og:url" content="http://www.lifeab.com/2024/04/08/jdk8%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="jdk8以上提高开发效率的新特性有哪些">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://mele.cool/image-20201002225245978.png">
<meta property="og:image" content="http://mele.cool/image-20201002225308032.png">
<meta property="og:image" content="http://mele.cool/image-20201002225809916.png">
<meta property="og:image" content="http://mele.cool/image-20201002232340066.png">
<meta property="og:image" content="http://mele.cool/image-20201003162011657.png">
<meta property="og:image" content="http://mele.cool/image-20201003162122297.png">
<meta property="og:image" content="http://mele.cool/image-20201003162440304.png">
<meta property="og:image" content="http://mele.cool/image-20201003162616742.png">
<meta property="og:image" content="http://mele.cool/image-20201003162744285.png">
<meta property="og:image" content="http://mele.cool/image-20201003162822708.png">
<meta property="og:image" content="http://mele.cool/image-20201003163113414.png">
<meta property="og:image" content="http://mele.cool/image-20201003163229028.png">
<meta property="og:image" content="http://mele.cool/image-20201003163318219.png">
<meta property="og:image" content="http://mele.cool/image-20201003163436119.png">
<meta property="og:image" content="http://mele.cool/image-20201003163527665.png">
<meta property="og:image" content="http://mele.cool/image-20201003163634259.png">
<meta property="og:image" content="http://mele.cool/image-20201003163858821.png">
<meta property="og:image" content="http://mele.cool/image-20201003164020818.png">
<meta property="og:image" content="http://mele.cool/image-20201003165624398.png">
<meta property="og:image" content="http://mele.cool/image-20201003170351987.png">
<meta property="og:image" content="http://mele.cool/image-20201003170559116.png">
<meta property="article:published_time" content="2024-04-08T07:56:17.000Z">
<meta property="article:modified_time" content="2024-04-08T08:54:11.566Z">
<meta property="article:author" content="John Wick">
<meta property="article:tag" content="java">
<meta property="article:tag" content="jdk8新特性">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://mele.cool/image-20201002225245978.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>jdk8以上提高开发效率的新特性有哪些 - 我的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.lifeab.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":4},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Freedom is as important as breathing</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="jdk8以上提高开发效率的新特性有哪些"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-08 15:56" pubdate>
          2024年4月8日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          83 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">jdk8以上提高开发效率的新特性有哪些</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="1-接口的默认方法和静态方法"><a href="#1-接口的默认方法和静态方法" class="headerlink" title="1.接口的默认方法和静态方法"></a>1.接口的默认方法和静态方法</h1><p><strong>众所周知，在接口中定义的普通方法都是抽象方法，方法前面默认都会添加public abstract，不能有方法实现，需要在接口的实现类中对方法进行具体实现。</strong></p>
<p>但是<strong>Java8开始允许在接口中定义默认方法和静态方法</strong>，对于这两种方法，可以直接在接口对其进行实现，无需再在接口实现类中进行实现。</p>
<ul>
<li>默认方法：又叫扩展方法，在方法前面需通过<code>default</code>修饰,不能直接通过接口调用，必须通过接口实现类的实例对象进行方法调用</li>
<li>静态方法：又叫类方法，在方法前面需通过<code>static</code>修饰。可以直接通过接口调用。</li>
</ul>
<p><strong>普通方法必须实现，默认方法可以选择性重写，静态方法无法重写。</strong></p>
<h1 id="2-lambda表达式"><a href="#2-lambda表达式" class="headerlink" title="2.lambda表达式"></a>2.lambda表达式</h1><blockquote>
<p><strong>Lambda表达式是Java8非常重要的一个新特性,其基于函数式编程的思想,支持将代码作为方法参数进行使用</strong>。可以把Lambda表达式理解为通过一种更加简洁的方式表示可传递的匿名函数。<br>它本身没有名称,而且不像方法那样属于某一个类,但是可以有参数列表、代码体、返回值。使用了Lambda表达式之后就不需要再去编写匿名类了。</p>
</blockquote>
<h2 id="2-1基础格式"><a href="#2-1基础格式" class="headerlink" title="2.1基础格式:"></a>2.1基础格式:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">(参数列表) ‐&gt; &#123;<br>	方法体<br>&#125;<br><span class="hljs-comment">//没有参数的Lambda表达式</span><br>()‐&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><span class="hljs-comment">//只有一个参数的Lambda表达式</span><br>x -&gt; &#123;<br>  System.out.println(x);<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">//有多个参数的Lambda表达式</span><br>(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)-&gt;&#123;<br>	System.out.println(x);<br>  System.out.println(y);<br>	<span class="hljs-keyword">return</span> x+y;<br>&#125;<br><span class="hljs-comment">//上述可以进行简写，因为在Lambda中，参数列表中参数的数据类型可以交给JVM根据上下文进行推断。所以可以不用定义类型。</span><br><span class="hljs-comment">//一个参数和仅一条语句的Lambda表达式</span><br>x-&gt;<span class="hljs-number">3</span>+x;<br><span class="hljs-comment">//多个参数和仅一条语句的Lambda表达式</span><br>(x,y) -&gt;x+y;<br></code></pre></td></tr></table></figure>

<h2 id="2-2-Lambda表达式底层原理解析"><a href="#2-2-Lambda表达式底层原理解析" class="headerlink" title="2.2 Lambda表达式底层原理解析"></a>2.2 <strong>Lambda</strong>表达式底层原理解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//lambda循环比较 </span><br>Arrays.sort(language,(o1,o2)‐&gt;(o1.compareTo(o2)));<br><br><span class="hljs-comment">//定义一个使用Lambda表达式的方法 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SourceDemo</span> &#123; <br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">()</span>&#123; <br>		String[] language = &#123;<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;c++&quot;</span>, <span class="hljs-string">&quot;c#&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>,<span class="hljs-string">&quot;hive&quot;</span>, <span class="hljs-string">&quot;php&quot;</span>&#125;; <br>		List&lt;String&gt; list = Arrays.asList(language);<br>    list.forEach(s‐&gt; System.out.println(s)); <br>    &#125; <br>    &#125;<br><span class="hljs-comment">//将当前.java文件编译生成.class文件，执行命令后，会在当前文件夹生成对应的.class文件 </span><br>javac SourceDemo.java<br><span class="hljs-comment">//将.class文件进行反编译，查看文件内容 </span><br>javap ‐p SourceDemo.class<br><span class="hljs-comment">//  生成内容如下</span><br>  Compiled from <span class="hljs-string">&quot;SourceDemo.java&quot;</span> <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.itheima.lambda.source.SourceDemo &#123; <br>    <span class="hljs-keyword">public</span> com.itheima.lambda.source.SourceDemo(); <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">()</span>; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lambda$demo$<span class="hljs-number">0</span>(java.lang.String); <br>  &#125;<br><span class="hljs-comment">//此时可以发现，代码中执行Lambda表达式的部分生成了一个静态私有函数。这个静态私有函数的函数干就是 Lambda表达式里面的内容。 那么对于这个静态私有函数，在JDK8内部是如何实现调用的呢？可以查看 LambdaMetafactory 类，该类下有一个 metafactory方法，lambda表达式每一次在执行的时候都会进入到这个方法中，并且为lambda表达式创建一个内 部类。</span><br><br><span class="hljs-comment">//如果想查看内部类里面的内容，可以在lambda表达式执行之前，添加 </span><br>System.setProperty(<span class="hljs-string">&quot;jdk.internal.lambda.dumpProxyClasses&quot;</span>, <span class="hljs-string">&quot;D://&quot;</span>); <br><span class="hljs-comment">//这个方法会将运行时生成的内部类class文件进行输出。 当该文件生成后，可以通过 javap -c -p class文件名 查看文件中的内容</span><br><span class="hljs-comment">//此时可以发现编译后的Lambda表达式已经被执行。</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>综上所述，Lambda表达式在执行的时候，会调用LambdaMetafactory.metafactory动态的生成内部类，在方法 内调用 SourceDemo$&amp;Lambda$1 ，内部类里的调用方法块并不是动态生成的，只是在原class里已经编译生成了一个 静态的方法，内部类只需要调用该静态方法。 </p>
</blockquote>
<h1 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3.函数式接口"></a>3.函数式接口</h1><blockquote>
<p>在Java8中为了让现在有的函数能够更加友好的使用Lambda表达式，因此引入了<strong>函数式接口</strong>这个概念。</p>
<p><strong>函数式接口是一个 仅有一个抽象方法的普通接口。如果声明多个抽象方法则会报错。</strong></p>
<p><strong>但是默认方法和静态方法在此接口中可以定义多个。</strong></p>
<p><strong>要想自定义一个函数式接口的话，需要在接口上添加 @FunctionalInterface 。</strong> </p>
<p>在<code>Java8</code>的类库设计中，已经引入了几个函数式接口：<code>Predicate</code>、<code>Consumer</code>、<code>Function</code>、<code>Supplier</code> </p>
</blockquote>
<h2 id="3-1-Predicate使用"><a href="#3-1-Predicate使用" class="headerlink" title="3.1 Predicate使用"></a>3.1 <strong>Predicate</strong>使用</h2><blockquote>
<p>Predicate接口是Java8定义的一个函数式接口,用于条件判断，属于**<code>java.util.function</code><strong>包下，</strong>内部定义一个 抽象方法<code>test</code>、三个默认方法<code>and</code>(与)，<code>negate</code>(非)，<code>or</code>(或)、一个静态方法<code>isEqual</code>** </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.itheima.lambda.Student;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPredicateDemo</span> &#123;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 定义方法,接收入参学生列表 和 函数式接口Predicate</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> studentList</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> predicate</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Student&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(List&lt;Student&gt; studentList, Predicate&lt;Student&gt; predicate)</span>&#123;<br>    ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    studentList.forEach(s‐&gt;&#123;<br>       <span class="hljs-keyword">if</span> (predicate.test(s))&#123;<br>        	list.add(s);<br>       &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> list;<br> &#125;<br> <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;M&quot;</span>));<br>    students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;M&quot;</span>));<br>    students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;王五&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>));<br>    <span class="hljs-comment">//通过lambda表达式调用filter方法</span><br>    List&lt;Student&gt; result = filter(students, (s) ‐&gt; s.getSex().equals(<span class="hljs-string">&quot;F&quot;</span>));<br>    System.out.println(result.toString());<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>and</code>用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoPredicateAnd</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isValid</span> <span class="hljs-operator">=</span> method(<br>                s -&gt; s.contains(<span class="hljs-string">&quot;H&quot;</span>), s -&gt; s.contains(<span class="hljs-string">&quot;W&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;字符串符合要求吗:&quot;</span> + isValid);<br>    &#125;<br><br>    <span class="hljs-comment">//定义过滤方法,两个条件都满足才返回true</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">method</span><span class="hljs-params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isValid</span> <span class="hljs-operator">=</span> one.and(two).test(<span class="hljs-string">&quot;Hello world&quot;</span>);<br>        <span class="hljs-keyword">return</span> isValid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-2-Consumer使用"><a href="#3-2-Consumer使用" class="headerlink" title="3.2 Consumer使用"></a>3.2 <strong>Consumer</strong>使用</h2><blockquote>
<p>Consumer也是JDK8提供的函数式接口，用于进行<strong>获取数据</strong>的操作，其内部定义了一个抽象方法<code>accept</code>、一个默认方法<code>andThen</code>。</p>
<p>对于<code>accept()</code>方法来说，它接受一个泛型<code>T</code>对象。如果现在需要访问类型<code>T</code>对象，并对其进行某些操作的话，就可以使用这个接口。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.haier.cscp.utils;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConsumerDemo</span> &#123;<br>    <span class="hljs-comment">//定义遍历方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foreach</span><span class="hljs-params">(List&lt;String&gt; arrays, Consumer&lt;String&gt; consumer)</span> &#123;<br>        arrays.forEach(s -&gt; consumer.accept(s));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; arrays = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        arrays.add(<span class="hljs-string">&quot;java&quot;</span>);<br>        arrays.add(<span class="hljs-string">&quot;python&quot;</span>);<br>        arrays.add(<span class="hljs-string">&quot;go&quot;</span>);<br>        arrays.add(<span class="hljs-string">&quot;hive&quot;</span>);<br>        <span class="hljs-comment">//调用遍历方法,传入集合和逻辑</span><br>        foreach(arrays, (s) -&gt; System.out.print(s + <span class="hljs-string">&quot;,&quot;</span>));<br>        System.out.println();<br>        <span class="hljs-comment">//集合继承了Iterable,而Iterable的forEach方法入参也是Consumer,故也可直接使用forEach</span><br>        arrays.forEach(s -&gt; System.out.print(s + <span class="hljs-string">&quot;,&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-3-Function使用"><a href="#3-3-Function使用" class="headerlink" title="3.3 Function使用"></a>3.3 <strong>Function</strong>使用</h2><blockquote>
<p>Function主要用于进行类型转换的操作。内部提供一个抽象方法<code>apply</code>、两个默认方法<code>compose</code>，<code>andThen</code>、一个 静态方法<code>identity</code> </p>
<p>对于apply方法，它接收一个泛型<code>T</code>对象，并返回一个泛型<code>R</code>的对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.test;<br><br><span class="hljs-keyword">import</span> java.util.function.Function;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFunctionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">convert</span><span class="hljs-params">(String value, Function&lt;String,Integer&gt; function)</span>&#123;<br>        <span class="hljs-keyword">return</span> function.apply(value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">convert</span> <span class="hljs-operator">=</span> convert(<span class="hljs-string">&quot;666&quot;</span>, value -&gt; Integer.valueOf(value)+<span class="hljs-number">222</span>);<br>        System.out.println(convert);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="3-4-Supplier使用"><a href="#3-4-Supplier使用" class="headerlink" title="3.4 Supplier使用"></a>3.4 <strong>Supplier</strong>使用</h2><blockquote>
<p>Supplier也是用来进行值获取操作，内部只有一个抽象方法get</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.test;<br><br><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySupplierDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">getMin</span><span class="hljs-params">(Supplier&lt;Integer&gt; supplier)</span>&#123;<br>        <span class="hljs-keyword">return</span>  supplier.get();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">22</span>,<span class="hljs-number">111</span>&#125;;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">min1</span> <span class="hljs-operator">=</span> getMin(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : arr) &#123;<br>                <span class="hljs-keyword">if</span> (min &gt; a) &#123;<br>                    min = a;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> min;<br>        &#125;);<br>        System.out.println(min1);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="3-5-类型检查-推断"><a href="#3-5-类型检查-推断" class="headerlink" title="3.5 类型检查**&amp;**推断"></a>3.5 类型检查**&amp;**推断</h2><blockquote>
<p>对于Lambda表达式的类型推断，它是对<code>Java7</code>中的目标类型推断进行的再次扩展。在<code>Java7</code>中引入了 <code>菱形操作符</code> 的概念，它可以是代码在编译时自动推断出泛型参数的类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//全量声明 </span><br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;(); <br><span class="hljs-comment">//菱形运算符 </span><br>Map&lt;String,String&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>

<p>第二种书写代码的方式，也是我们在开发中经常使用的。不用明确声明泛型类型，代码在进行编译时，可以自动的进行类型推断。 </p>
<p>那么在Java8中对于这种使用方式又进一步扩展，可以省略Lambda表达式中的所有参数类型。在编译时根据Lambda表达式的上下文信息推断出参数的正确类型。这就是所谓的类型推断。</p>
<blockquote>
<p>到现在为止，对于Lambda表达式都只用到了方法体里面的参数，但Lambda其实是支持使用外部定义的变量的。在下面这段代码中，在Lambda表达式内部引用了外部变量。<strong>但是当在Lambda方法体内使用外部变量时，其必须声明为final。下述代码虽然没有显示的声明，但是在Java8它自动的会对需要为final的变量(port)进行转换。</strong> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">()</span>&#123; <br>  <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">8086</span>; <br>  <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> ()‐&gt; System.out.println(port); <br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用::"></a>4. 方法引用<code>::</code></h1><p>方法引用更近一步的优化了Lambda的使用。它让代码感觉更加的自然。我们可以直接使用 <code>::</code> 来简化<code>Lambda</code>表达式的使用。</p>
<p>使用语法如下： <code>类名或实例名::方法名</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">students.sort(Comparator.comparing(Student::getId)); <br></code></pre></td></tr></table></figure>

<h1 id="5-Stream流使用"><a href="#5-Stream流使用" class="headerlink" title="5. Stream流使用"></a><strong>5. Stream</strong>流使用</h1><blockquote>
<p>流操作是Java8提供一个重要新特性，它允许开发人员以声明性方式处理集合，其<strong>核心类库主要改进了对集合类的 API和新增Stream操作</strong>。Stream类中每一个方法都对应集合上的一种操作。将真正的函数式编程引入到Java中，能 让代码更加简洁，极大地简化了集合的处理操作，提高了开发的效率和生产力。 </p>
<p><strong>stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或<code>I/O channel</code>等。在Stream中的操作每一次都会产生新的流，内部不会像普通集合操作一样立刻获取值，而是惰性取值，只有等到用户真正需要结果的时候才会执行。</strong> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; result = studentList.stream() <br>  .filter(s ‐&gt; s.getAge() &lt; <span class="hljs-number">20</span>) <span class="hljs-comment">//过滤出年龄小于20岁的学生 </span><br>  .sorted(Comparator.comparing(Student::getAge)) <span class="hljs-comment">//对结果进行排序 </span><br>  .map(Student::getName) <span class="hljs-comment">// 提取出结合中的name属性 </span><br>  .collect(Collectors.toList());<span class="hljs-comment">//转换成一个新的集合</span><br></code></pre></td></tr></table></figure>

<p>通过上述代码的执行，可以发现<strong>无需再去定义过多的冗余变量</strong>。我们可以将多个操作组成一个调用链，形成数据处理的流水线。在减少代码量的同时也更加的清晰易懂。 </p>
<p>并且对于现在调用的方法，本身都是一种高层次构件，与线程模型无关。因此在并行使用中，<strong>开发者们无需再去操心线程和锁了。Stream内部都已经做好了。</strong></p>
<p>steam流本身就是将集合的操作由外部迭代转换为了内部迭代。而内部迭代来说，它所操作的就是不是一个集合了，而是一个流。它会将所有的操作融合在流中，由其在内部进行处理，这种隐式的方式称之为<strong>内部迭代</strong>。 </p>
<p><strong>并且内部迭代支持并行处理，更利于集合操作的性能优化。其关注与对数据的计算。</strong> </p>
<h2 id="5-1流操作详解"><a href="#5-1流操作详解" class="headerlink" title="5.1流操作详解"></a>5.1流操作详解</h2><p><strong>Stream流接口中定义了许多对于集合的操作方法,总的来说可以分为两大类:中间操作和终端操作。</strong></p>
<ul>
<li><strong>中间操作</strong>:会返回一个流,通过这种方式可以将多个中间操作连接起来,形成一个调用链,从而转换为另外一个流。除非调用链最后存在一个终端操作,否则中间操作对流不会进行任何结果处理。</li>
<li><strong>终端操作</strong>:会返回一个具体的结果,如<code>boolean</code>, <code>list</code>, <code>integer</code>等。</li>
</ul>
<h3 id="5-1-1筛选filter-distinct"><a href="#5-1-1筛选filter-distinct" class="headerlink" title="5.1.1筛选filter distinct"></a>5.1.1筛选<code>filter distinct</code></h3><p>对于集合的操作，经常性的会涉及到对于集中符合条件的数据筛选，Stream中对于数据筛选两个常见的API：<code>filter</code>(过滤)、<code>distinct</code>(去重) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//filter</span><br>Stream&lt;Student&gt; studentStream = studentList.stream() <br>																.filter(s‐&gt;s.getAge() &lt; <span class="hljs-number">20</span>); <span class="hljs-comment">//.filter(Student::getIsPass);</span><br>List&lt;Student&gt; list = studentStream.collect(Collectors.toList());<br><span class="hljs-comment">//distinct 对对象进行去重的话，还需要在对象内部重写，hashCode()和equals()方法才可以实现去重。</span><br>List&lt;Integer&gt; result = numberList.stream() <br>  .filter(n ‐&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <br>  .distinct() <br>  .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>

<h3 id="5-1-2-切片limit-skip"><a href="#5-1-2-切片limit-skip" class="headerlink" title="5.1.2 切片limit skip"></a>5.1.2 切片<code>limit skip</code></h3><blockquote>
<p>基于**<code>limit()</code>**实现数据截取,该方法会返回一个不超过给定长度的流。</p>
<p>对于<code>limit</code>方法的实现，它会接收截取的长度，如果该值小于0，则抛出异常，否则会继续向下调用 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numberList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <br>List&lt;Integer&gt; collect = numberList.stream().limit(<span class="hljs-number">5</span>).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>

<blockquote>
<p>基于**<code>skip()</code>**实现数据跳过,刚才已经基于<code>limit</code>完成了数据截取，但是<code>limit</code>对于数据截取是从前往后截取几个。如果现在对结果只获取后几个怎么办呢？此时就需要使用<code>skip()</code>。其与<code>limit()</code>的使用是相辅相成的。 </p>
<p>在<code>skip</code>方法中接收的<code>n</code>代表的是要跳过的元素个数，如果<code>n</code>小于<code>0</code>，抛出非法参数异常，如果<code>n</code>等于<code>0</code>，则返回当前 流。如果<code>n</code>大于<code>0</code>，才会调用<code>makeRef()</code>。同时指定limit参数为-1. </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; numberList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>    List&lt;Integer&gt; collect = numberList.stream().limit(<span class="hljs-number">5</span>).skip(<span class="hljs-number">2</span>).collect(Collectors.toList());<br>    System.out.println(collect);<span class="hljs-comment">//[3, 4, 1]</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-1-3映射-map"><a href="#5-1-3映射-map" class="headerlink" title="5.1.3映射  map"></a>5.1.3映射  <code>map</code></h3><blockquote>
<p>在对集合进行操作的时候，我们经常会从某些对象中选择性的提取某些元素的值，就像编写<code>sql</code>一样，指定获取表 中特定的数据列 :</p>
<p>  <code>SELECT name FROM student;</code> </p>
<p>在Stream API中也提供了类似的方法，<code>map()</code>。它接收一个函数作为方法参数，这个函数会被应用到集合中每一个 元素上，并最终将其映射为一个新的元素。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取每一个学生的名字，并形成一个新的集合 </span><br>List&lt;String&gt; nameList = studentList.stream() <br>  .map(Student::getName) <br>  .collect(Collectors.toList());<br><span class="hljs-comment">//获取每一个学生名字的长度</span><br>List&lt;Integer&gt; nameList = studentList.stream()<br>  .map(Student::getName)<br>  .map(String::length) <span class="hljs-comment">//也可以继续向下获取每一个名称的长度 </span><br>  .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>

<h3 id="5-1-4匹配anyMatch-allMatch"><a href="#5-1-4匹配anyMatch-allMatch" class="headerlink" title="5.1.4匹配anyMatch allMatch"></a>5.1.4匹配<code>anyMatch allMatch</code></h3><blockquote>
<p>有时还需要判断集合中某些元素是否匹配对应的条件，如果有的话，在进行后续的操作。在 Stream API中也提供了相关方法供我们进行使用，如<code>anyMatch</code>、<code>allMatch</code>等。他们对应的就是<code>&amp;&amp;</code>和<code>||</code>运算符。</p>
<p><code>anyMatch()</code>主要用于判断流中是否至少存在一个符合条件的元素，它会返回一个<code>boolean</code>值，并且对于它的操作， 一般叫做<u>短路求值</u> (某些操作不用操作整个流就可以得到结果:<code>&amp;&amp;  ||</code> )</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//anyMatch执行时，只要流中有一个元素符合条件就会返回true</span><br><span class="hljs-keyword">if</span> (studentList.stream().anyMatch(s‐&gt;s.getAge()&lt;<span class="hljs-number">20</span>))&#123; <br>		System.out.println(<span class="hljs-string">&quot;集合中有符合条件的学生&quot;</span>); <br>&#125;<br><span class="hljs-comment">//allMatch会判断流中是否所有条件都符合条件，全部符合才会返回true</span><br><span class="hljs-keyword">if</span> (studentList.stream().allMatch(Student::getIsPass))&#123; <br>  System.out.println(<span class="hljs-string">&quot;所有学生合格&quot;</span>); <br>&#125;<span class="hljs-keyword">else</span> &#123; <br>  System.out.println(<span class="hljs-string">&quot;有学生不合格&quot;</span>); <br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="5-1-5查找findany-findFirst"><a href="#5-1-5查找findany-findFirst" class="headerlink" title="5.1.5查找findany findFirst"></a>5.1.5查找<code>findany findFirst</code></h3><ul>
<li><code>findany</code></li>
</ul>
<blockquote>
<p><code>fifindAny</code>用于获取流中随机的某一个元素，并且利用短路在找到结果时，立即结束。</p>
<p><code>fifindAny</code>对于同一数据源的多次操作会返回不同的结果。但是，如果我们的操作是串行的， 在数据较少的情况下，一般会返回第一个结果，如果在并行的情况下，那就不能确保返回的是第一个了。 </p>
<p>这种设计主要是为了获取更加高效的性能</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Student&gt; optional = studentList.stream().filter(s ‐&gt; s.getAge() &lt; <span class="hljs-number">20</span>).findAny(); <br><span class="hljs-keyword">if</span> (optional.isPresent())&#123; <br>	System.out.println(optional.get()); <br>&#125;<br><span class="hljs-comment">//并行流</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123; <br>  Optional&lt;Student&gt; optional = studentList.parallelStream().filter(s ‐&gt; s.getAge() &lt; <span class="hljs-number">20</span>).findAny();<br>  <span class="hljs-keyword">if</span> (optional.isPresent())&#123; <br>    System.out.println(optional.get()); <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>findFirst</code></li>
</ul>
<blockquote>
<p><code>fifindFirst</code>使用原理与<code>fifindAny</code>类似，但不管是在并行还是串行，指定返回流中的第一个元素。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123; <br>  Optional&lt;Student&gt; optional = studentList <br>    .stream() <br>    <span class="hljs-comment">//.parallelStream() </span><br>    .filter(s ‐&gt; s.getAge() &lt; <span class="hljs-number">20</span>) <br>    .findFirst(); <br>  <span class="hljs-keyword">if</span> (optional.isPresent())&#123; <br>    System.out.println(optional.get()); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-1-6-归约-求和、最大值、最小值等"><a href="#5-1-6-归约-求和、最大值、最小值等" class="headerlink" title="5.1.6 归约(求和、最大值、最小值等)"></a>5.1.6 归约(求和、最大值、最小值等)</h3><blockquote>
<p>到现在截止，对于流的终端操作，我们返回的有<code>boolean</code>、<code>Optional</code>和<code>List</code>。但是在集合操作中，我们经常会涉及 对元素进行统计计算之类的操作，如求和、求最大值、最小值等，从而返回不同的数据结果。 </p>
</blockquote>
<h4 id="5-1-6-1累积求和"><a href="#5-1-6-1累积求和" class="headerlink" title="5.1.6.1累积求和"></a>5.1.6.1累积求和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一个参数声明为初始值，第二个参数接收一个lambda表达式，代表当前流中的两个元素，它会反复相加每一个元素，直到流被归约成一个最终结果</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">reduce</span> <span class="hljs-operator">=</span> numbers.stream().reduce(<span class="hljs-number">0</span>, (a, b) ‐&gt; a + b);<br><span class="hljs-comment">//优化:Integer类中提供了sum方法，用于对两个数求和，这里我们可 以直接基于lambda方法调用的形式来使用</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">reduce</span> <span class="hljs-operator">=</span> numbers.stream().reduce(<span class="hljs-number">0</span>, Integer::sum);<br><span class="hljs-comment">//继续优化:reduce方法还有一个重载方法，不需要初始化值，会返回一个 Optional对象</span><br>Optional&lt;Integer&gt; optional = numbers.stream().reduce(Integer::sum);<br></code></pre></td></tr></table></figure>

<h4 id="5-1-6-2最大值最小值"><a href="#5-1-6-2最大值最小值" class="headerlink" title="5.1.6.2最大值最小值"></a>5.1.6.2最大值最小值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//最大值</span><br>Optional&lt;Integer&gt; optional = numbers.stream().reduce(Integer::max)<br><span class="hljs-comment">//优化</span><br>Optional&lt;Integer&gt; optional = numbers.stream().max(Integer::compareTo);<br><span class="hljs-comment">//最小值</span><br>Optional&lt;Integer&gt; min = numbers.stream().min(Integer::compareTo);<br></code></pre></td></tr></table></figure>

<h2 id="5-2构建流"><a href="#5-2构建流" class="headerlink" title="5.2构建流"></a>5.2构建流</h2><blockquote>
<p>难道Stream只能在集合基础上才能操作么？当然不是，我们还可以基于值、数组甚至文件来构建流，完成流操作。</p>
</blockquote>
<h3 id="5-2-1基于值创建流"><a href="#5-2-1基于值创建流" class="headerlink" title="5.2.1基于值创建流"></a>5.2.1基于值创建流</h3><blockquote>
<p>在Stream中提供了一个静态方法<code>of</code>，它可以接收任意数量参数，显式的创建一个流。并且会根据传入的参数类 型，构建不同泛型的流。</p>
<p>其内部就是基于<code>Arrays</code>中的<code>stream</code>方法将传入的多个参数转换为数组，然后创建流，并遍历数组，将每一个元素放入流中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stringStream = Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>); <br>Stream&lt;Object&gt; stream = Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">3</span>,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">St</span>());<br></code></pre></td></tr></table></figure>

<h3 id="5-2-2基于数组创建流"><a href="#5-2-2基于数组创建流" class="headerlink" title="5.2.2基于数组创建流"></a>5.2.2基于数组创建流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>Stream&lt;Integer&gt; integerStream = Arrays.stream(numbers);<br></code></pre></td></tr></table></figure>

<h3 id="5-2-3基于文件创建流"><a href="#5-2-3基于文件创建流" class="headerlink" title="5.2.3基于文件创建流"></a>5.2.3基于文件创建流</h3><p>​	在Java中 提供了<code>Files</code>类，该类中提供了一些对于文件操作的相关方法。可以看下<code>Files</code>类中部分方法</p>
<p>​	在该类中部分方法返回值就是Stream，如：<code>newDirectoryStream</code>、<code>list</code>、<code>lines</code>等。 </p>
<h2 id="5-3收集器-返回复杂数据类型"><a href="#5-3收集器-返回复杂数据类型" class="headerlink" title="5.3收集器(返回复杂数据类型)"></a>5.3收集器(返回复杂数据类型)</h2><blockquote>
<p>对于数据的返回，我们返回的都是一些简单的数据类型。那现在我们要做一些复杂的数据返回，应该怎么做呢？ 比方说返回一个Map或者List。就需要通过收集器来实现了</p>
<p>其内部主要核心是通过<code>Collectors</code>完成更加复杂的计算转换，从而获取到最终结果。并且<code>Collectors</code>内部提供了非常多的常用静态方法，直接拿来就可以了。比方说：<code>toList</code>。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据年龄进行分组</span><br>Map&lt;Integer, List&lt;Student&gt;&gt; map = studentList.stream().collect(Collectors.groupingBy(Student::getAge));<br></code></pre></td></tr></table></figure>

<h3 id="5-3-1-通过-counting-统计集合总数"><a href="#5-3-1-通过-counting-统计集合总数" class="headerlink" title="5.3.1 通过**counting()**统计集合总数"></a>5.3.1 通过**<code>counting()</code>**统计集合总数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">collect</span> <span class="hljs-operator">=</span> studentList.stream().collect(Collectors.counting());<br><span class="hljs-comment">//简写</span><br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> studentList.stream().count();<br></code></pre></td></tr></table></figure>

<h3 id="5-3-2-通过-maxBy-与minBy-获取最大值最小值"><a href="#5-3-2-通过-maxBy-与minBy-获取最大值最小值" class="headerlink" title="5.3.2 通过**maxBy()与minBy()**获取最大值最小值"></a>5.3.2 通过**<code>maxBy()</code><strong>与</strong><code>minBy()</code>**获取最大值最小值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取年龄最大的学生 </span><br>Optional&lt;Student&gt; optional = studentList.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)));<br><span class="hljs-comment">//优化</span><br>Optional&lt;Student&gt; studentOptional = studentList.stream().max(Comparator.comparing(Student::getAge));<br><span class="hljs-comment">//获取年龄最小的学生 </span><br>Optional&lt;Student&gt; studentOptional = studentList.stream().min(Comparator.comparing(Student::getAge));<br></code></pre></td></tr></table></figure>

<h3 id="5-3-3-通过-summingInt-进行数据汇总"><a href="#5-3-3-通过-summingInt-进行数据汇总" class="headerlink" title="5.3.3 通过**summingInt()**进行数据汇总"></a>5.3.3 通过**<code>summingInt()</code>**进行数据汇总</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取年龄总和</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">collect</span> <span class="hljs-operator">=</span> studentList.stream().collect(Collectors.summingInt(Student::getAge));<br><span class="hljs-comment">//简化</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> studentList.stream().mapToInt(Student::getAge).sum();<br></code></pre></td></tr></table></figure>

<h3 id="5-3-4-通过-averagingInt-进行平均值获取"><a href="#5-3-4-通过-averagingInt-进行平均值获取" class="headerlink" title="5.3.4 通过**averagingInt()**进行平均值获取"></a>5.3.4 通过**<code>averagingInt()</code>**进行平均值获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Double</span> <span class="hljs-variable">collect</span> <span class="hljs-operator">=</span> studentList.stream().collect(Collectors.averagingInt(Student::getAge));<br><span class="hljs-comment">//另外一种 这种方式虽然代码写多了一些，但是可以防止空值的出现。</span><br><span class="hljs-type">OptionalDouble</span> <span class="hljs-variable">average</span> <span class="hljs-operator">=</span> studentList.stream().mapToDouble(Student::getAge).average(); <br><span class="hljs-keyword">if</span> (average.isPresent())&#123; <br>  <span class="hljs-type">double</span> <span class="hljs-variable">asDouble</span> <span class="hljs-operator">=</span> average.getAsDouble(); <br>  System.out.println(asDouble); <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-3-5复杂结果返回"><a href="#5-3-5复杂结果返回" class="headerlink" title="5.3.5复杂结果返回"></a>5.3.5复杂结果返回</h3><blockquote>
<p>到此截止，已经通过收集器完成了汇总、求和、求最大最小值、求平均值的操作。但是值得注意的是，这些操作每 一次都是返回单独的一个值，但是日常开发中，经常需要获取多种内容，那这种需求应该如何完成？Collectors也 提供了相关静态方法进行解决，这三个方法可以，返回的都是收集器。其内部已经包含了多种结果内容 </p>
<p>上述方法返回了<code>IntSummaryStatistics</code>类，其内部提供了相关<code>getter</code>方法用于获取汇总值、总和、最大值最小值等 方法，直接调用即可 </p>
<p>对于另外的<code>summarizingDouble()</code>和<code>summarizingLong()</code>使用方式都是相同的。只不过他们适用于收集属性数据类 型为<code>double</code>和<code>long</code>而已。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">collect</span> <span class="hljs-operator">=</span> studentList.stream().collect(Collectors.summarizingInt(Student::getAge));<br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> collect.getCount(); <br><span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> collect.getSum(); <br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> collect.getMax(); <br><span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> collect.getMin(); <br><span class="hljs-type">double</span> <span class="hljs-variable">average</span> <span class="hljs-operator">=</span> collect.getAverage();<br></code></pre></td></tr></table></figure>

<h3 id="5-3-6通过-joining-进行数据拼接"><a href="#5-3-6通过-joining-进行数据拼接" class="headerlink" title="5.3.6通过**joining()**进行数据拼接"></a>5.3.6通过**joining()**进行数据拼接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">collect</span> <span class="hljs-operator">=</span> studentList.stream().map(Student::getName).collect(Collectors.joining());<br><span class="hljs-type">String</span> <span class="hljs-variable">collect</span> <span class="hljs-operator">=</span> studentList.stream().map(Student::getName).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br></code></pre></td></tr></table></figure>

<h3 id="5-3-7-分组"><a href="#5-3-7-分组" class="headerlink" title="5.3.7 分组"></a>5.3.7 分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一级分组 根据年龄分组</span><br>Map&lt;Integer, List&lt;Student&gt;&gt; map = studentList.stream().collect(Collectors.groupingBy(Student::getAge))<br><span class="hljs-comment">//根据年龄 是否通过进行多级分组</span><br>Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(student ‐&gt; &#123; <br>  <span class="hljs-keyword">if</span> (student.getIsPass()) &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pass&quot;</span>; <br>  &#125; <span class="hljs-keyword">else</span> &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;not pass&quot;</span>; <br>  &#125; <br>&#125;)));<br><span class="hljs-comment">//多级分组变形 </span><br><span class="hljs-comment">//根据年龄进行分组，获取并汇总人数 </span><br>Map&lt;Integer, Long&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.counting())); <br><span class="hljs-comment">//根据年龄与是否及格进行分组，并汇总人数</span><br>Map&lt;Integer, Map&lt;Boolean, Long&gt;&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(Student::getIsPass, Collectors.counting())));<br><span class="hljs-comment">//根据年龄与是否及格进行分组，并获取每组中分数最高的学生</span><br>Map&lt;Integer, Map&lt;Boolean, Student&gt;&gt; collect = studentList.stream().collect( Collectors.groupingBy(Student::getAge, <br>                                                                                               		Collectors.groupingBy(Student::getIsPass, <br>                                                                                                                     			Collectors.collectingAndThen( <br>                                                                                                                       				Collectors.maxBy( <br>                                                                                                                         						Comparator.comparing(Student::getScore)), Optional::get))));<br></code></pre></td></tr></table></figure>

<h3 id="5-3-8-自定义收集器"><a href="#5-3-8-自定义收集器" class="headerlink" title="5.3.8 自定义收集器"></a>5.3.8 自定义收集器</h3><blockquote>
<p>根据源码，<code>Collector</code>接口需要三个参数。T：流中要收集的元素类型、A：累加器的类型、R：收集的结果类型。 </p>
<p>如想自定义收集器，需要实现Collector接口中的五个方法：<code>supplier</code>、<code>accumulator</code>、<code>fifinisher</code>、<code>combiner</code>、 </p>
<p><code>characteristics</code> </p>
<ul>
<li><p><code>supplier</code>：用于创建一个容器，在调用它时，需要创建一个空的累加器实例，供后续方法使用。 </p>
</li>
<li><p><code>accumulator</code>：基于supplier中创建的累加容器，进行累加操作。 </p>
</li>
<li><p><code>fifinisher</code>：当遍历完流后，在其内部完成最终转换，返回一个最终结果。 </p>
</li>
<li><p><code>combiner</code>：用于在并发情况下，将每个线程的容器进行合并。 </p>
</li>
<li><p><code>characteristics</code>：用于定义收集器行为，如是否可以并行或使用哪些优化。其本身是一个枚举，内部有三个值，分别为： </p>
<p><code>CONCURRENT</code>：表明收集器是并行的且只会存在一个中间容器。 </p>
<p><code>UNORDERED</code>：表明结果不受流中顺序影响，收集是无序的。 </p>
<p><code>IDENTITY_FINISH</code>：表明累积器的结果将会直接作为归约的最终结果，跳过fifinisher()。</p>
</li>
</ul>
</blockquote>
<p>自定义收集器，返回所有合格的学员:</p>
<p><img src="http://mele.cool/image-20201002225245978.png" srcset="/img/loading.gif" lazyload alt="image-20201002225245978"></p>
<p>使用自定义收集器 :</p>
<p><img src="http://mele.cool/image-20201002225308032.png" srcset="/img/loading.gif" lazyload alt="image-20201002225308032"></p>
<h1 id="6-数据并行化"><a href="#6-数据并行化" class="headerlink" title="6.数据并行化"></a>6.数据并行化</h1><blockquote>
<p>为了让数据处理更加高效，<code>Java8</code>对于<code>Stream</code>也提供了并行的操作方式，在<code>Java7</code>之前如果要对数据并行处理，需要开发人员做的事情很多，如数据如何进行分块、开启多少个线程、哪个线程负责哪部分数据、出现线程竞争怎么办等等的问题。 </p>
<p><code>Java8</code>对于数据并行化处理的实现非常简单，直接调用一个<code>parallelStream()</code>就可以开启并行化处理。</p>
<ul>
<li>并行：多个任务在同一时间点发生，并由不同的<code>cpu</code>进行处理，不互相抢占资源</li>
<li>并发：多个任务在同一时间点内同时发生了，但由同一个<code>cpu</code>进行处理，互相抢占资源</li>
</ul>
<p>当在大量数据处理上，数据并行化可以大量缩短任务的执行时间，将一个数据分解成多个部分，然后并行处理，最后将多个结果汇总，得到最终结果。 </p>
<p><code>int sum = numbers.parallelStream().mapToInt(i ‐&gt; i).sum();</code> </p>
<p><strong>当将stream()切换为parallelStream()后，则完成了串行转换为并行的实现。</strong> </p>
</blockquote>
<h2 id="6-1并行流原理"><a href="#6-1并行流原理" class="headerlink" title="6.1并行流原理"></a>6.1并行流原理</h2><p>对于并行流，其在底层实现中，是沿用了Java7提供的fork&#x2F;join分解合并框架进行实现。fork根据<strong>cpu</strong>核数进行数据分块，join对各个fork进行合并。实现过程如下所示：</p>
<p><img src="http://mele.cool/image-20201002225809916.png" srcset="/img/loading.gif" lazyload alt="image-20201002225809916"></p>
<h2 id="6-2并行流注意事项"><a href="#6-2并行流注意事项" class="headerlink" title="6.2并行流注意事项"></a>6.2并行流注意事项</h2><p>对于并行流，一定不要陷入一个误区：并行一定比串行快。并行在不同的情况下它不一定是比串行快的。影响并行流性能主要存在5个因素： </p>
<p><strong>1）数据大小：</strong>输入数据的大小，直接影响了并行处理的性能。因为在并行内部实现中涉及到了fork&#x2F;join操作，它本身就存在性能上的开销。因此<strong>只有当数据量很大，使用并行处理才有意义。</strong> </p>
<p><strong>2）源数据结构</strong>：fork时会对源数据进行分割，数据源的特性直接影响了fork的性能。 </p>
<ul>
<li>ArrayList、数组或IntStream.range，可分解性最佳，因为他们都支持随机读取，因此可以被任意分割。 </li>
<li>HashSet、TreeSet，可分解性一般，其虽然可被分解，但因为其内部数据结构，很难被平均分解。 </li>
<li>LinkedList、Streams.iterate、BufferedReader.lines，可分解性极差，因为他们长度未知，无法确定在哪里进行分割。</li>
</ul>
<p><strong>3）装箱拆箱</strong> </p>
<ul>
<li><strong>尽量使用基本数据类型，避免装箱拆箱。</strong></li>
</ul>
<p><strong>4）CPU核数</strong> </p>
<ul>
<li>fork的产生数量是与可用CPU核数相关，可<strong>用的核数越多，获取的性能提升就会越大。</strong></li>
</ul>
<p><strong>5）单元处理开销</strong> </p>
<ul>
<li><strong>花在流中每个元素的时间越长，并行操作带来的性能提升就会越明显</strong>。</li>
</ul>
<h2 id="6-3结论"><a href="#6-3结论" class="headerlink" title="6.3结论"></a>6.3结论</h2><p><strong>根据性能测试可知，对于简单操作，如果环境机是多核的话，建议使用Stream并行，同时在不考虑核数的情况*下，普通for循环性能要明显高于Stream串行，相差两倍左右。</strong></p>
<p><strong>对于复杂操作，推荐使用Stream API操作。</strong> </p>
<h1 id="7-异步编程CompletableFuture"><a href="#7-异步编程CompletableFuture" class="headerlink" title="7.异步编程CompletableFuture"></a>7.异步编程<code>CompletableFuture</code></h1><blockquote>
<p>在现在软件开发的环境下，经常需要考虑如何能够设计出性能更加优异的系统。就像上面提到的数据并行化，就 是充分利用多核处理器结合并行操作来让代码执行效率更加优异。第二种方式就是让功能方法能够并行执行(异步编程CompletableFuture)。 </p>
</blockquote>
<h2 id="7-1Future介绍"><a href="#7-1Future介绍" class="headerlink" title="7.1Future介绍"></a>7.1<code>Future</code>介绍</h2><p>有的同学会说，对于任务并行需求，直接通过多线程实现不就可以了， 要注意，对于多线程的实现，java提 供了三种方式：继承Thread类、实现Runnable接口和实现Callable接口。但是业务代码在执行时会考虑执行顺序 的问题，直接基于这些方式实现多线程会出现两个问题： </p>
<p>1）要想控制线程执行顺序，会通过join()等待线程结束，那这样的话又回归到了阻塞式调用的思路上，违背了并行的需求。 另外还可以通过wait()、notify()、notifyAll()结合状态变量实现，但实现起来过于复杂。 </p>
<p>2）线程执行完之后，要想获取线程执行结果，还要用过共享变量或线程间通信等方式来获取，同样过于复杂。 为了解决上述问题，Java5中推出了<strong>Future</strong>，其初衷就是用于构建复杂并行操作。内部方法在返回时，不是返回一个值，而是返回Future对象。 其本质是在执行主业务的同时，异步的执行其他分业务，从而利用原本需要同步执行时的等待时间去执行其他的业 务，当需要获取其结果时，再进行获取。 </p>
<p><strong>在Future接口中有五个抽象方法：</strong> </p>
<ol>
<li>cancel()：取消任务, 取消成功返回true；入参mayInterruptIfRunning表示是否允许取消正在执行中的任务。 </li>
<li>isCancelled()：返回布尔值，代表是否取消成功。</li>
<li>isDone()：返回布尔值，代表是否执行完毕。 </li>
<li>get()：返回Future对象，获取执行结果，如果任务没有完成会阻塞到任务完成再返回。 </li>
<li>get(long timeout, TimeUnit unit)：获取执行结果并设置超时时间，如果超时则抛出TimeoutException</li>
</ol>
<h2 id="7-2CompletableFuture"><a href="#7-2CompletableFuture" class="headerlink" title="7.2CompletableFuture"></a>7.2CompletableFuture</h2><p>CompletableFuture是Java1.8提供的一个新类，其实现了Future与CompletionStage两个接口。提供了诸多API扩展功能，可以通过Stream形式简化异步编程的复杂度，同时提供通过回调方式处理计算结果。</p>
<h3 id="7-2-1-异步任务创建"><a href="#7-2-1-异步任务创建" class="headerlink" title="7.2.1 异步任务创建"></a>7.2.1 异步任务创建</h3><p>在CompletableFuture中提供了四个静态方法用于创建异步任务 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据源码可知，runAsync()分为一个参数和两个参数，并且其内部都会调用asyncRunStage().</span><br><span class="hljs-comment">//在该方法内部会创建异步任务，并把任务放入线程池中。并且runAsync()是没有返回值的。</span><br><span class="hljs-comment">//根据源码可知，当传入Executor会使用指定线程池执行，如果没有传入则使用默认ForkJoinPool.commonPool()执 行，值得注意的是，commonPool中都是守护线程，主线程执行完，子线程也就over了。因此建议当任务非常耗 时，使用自定义线程池。</span><br><span class="hljs-number">1.</span>runAsync(Runnable runnable) <br><span class="hljs-number">2.</span>runAsync(Runnable runnable,Executor executor) <br><span class="hljs-comment">//根据源码可知，supplyAsync()分为一个参数和两个参数，并且其内部都会调用asyncSupplyStage().</span><br>  <span class="hljs-comment">//现在可知，其实supplyAsync()与runAsync()内部原理类似，但supplyAsync()有返回值。</span><br><span class="hljs-number">3.</span>supplyAsync(Supplier&lt;U&gt; supplier) <br><span class="hljs-number">4.</span>supplyAsync(Supplier&lt;U&gt; supplier,Executor executor)<br>  <br></code></pre></td></tr></table></figure>

<p>使用示例:</p>
<p><img src="http://mele.cool/image-20201002232340066.png" srcset="/img/loading.gif" lazyload alt="image-20201002232340066"></p>
<h3 id="7-2-2-异步计算结果触发回调"><a href="#7-2-2-异步计算结果触发回调" class="headerlink" title="7.2.2 异步计算结果触发回调"></a>7.2.2 异步计算结果触发回调</h3><blockquote>
<p>当异步任务结束或者抛出异常时，还要根据结果来完成特定的操作，对于这种需求CompletableFuture也提供了方法进行实现 </p>
</blockquote>
<h4 id="7-2-2-1whenComplete-与whenCompleteAsync"><a href="#7-2-2-1whenComplete-与whenCompleteAsync" class="headerlink" title="7.2.2.1whenComplete()与whenCompleteAsync()"></a><strong>7.2.2.1whenComplete()<strong>与</strong>whenCompleteAsync()</strong></h4><p>whenComplete是在当前任务线程中继续执行指定的特定处理，而whenCompleteAsync会将指定的特定交给线程池另开启一个线程来执行。</p>
<p><img src="http://mele.cool/image-20201003162011657.png" srcset="/img/loading.gif" lazyload alt="image-20201003162011657"></p>
<h4 id="7-2-2-2-exceptionally"><a href="#7-2-2-2-exceptionally" class="headerlink" title="7.2.2.2 exceptionally()"></a>7.2.2.2 <strong>exceptionally()</strong></h4><blockquote>
<p>exceptionally()与上述两个方法类似，都是用于当异步任务结束后，执行特定处理，但不同的是，上述两个方法即 可以处理正常的返回结果也可以处理异常，而exceptionally()只对异常进行处理，且其使用的是主线程。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162122297.png" srcset="/img/loading.gif" lazyload alt="image-20201003162122297"></p>
<h3 id="7-2-3-多任务依赖执行"><a href="#7-2-3-多任务依赖执行" class="headerlink" title="7.2.3 多任务依赖执行"></a>7.2.3 多任务依赖执行</h3><h4 id="7-2-3-1-thenApply"><a href="#7-2-3-1-thenApply" class="headerlink" title="7.2.3.1 thenApply()"></a>7.2.3.1 <strong>thenApply()</strong></h4><blockquote>
<p>该方法会接收一个Function，用于声明后续要执行的业务，其中T代表上一个方法的执行结果，fn代表当前任务的 结果数据类型，最终其会映射到CompletableFuture中的结果数据类型。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162440304.png" srcset="/img/loading.gif" lazyload alt="image-20201003162440304"></p>
<p>根据运行结果可以看到，此处通过thenApply()串接了两个任务，第二个方法会在第一个方法执行完成后触发，且第二个方法的执行依赖于第一个方法的执行结果。 </p>
<h4 id="7-2-3-2-handle"><a href="#7-2-3-2-handle" class="headerlink" title="7.2.3.2 handle()"></a>7.2.3.2 <strong>handle()</strong></h4><blockquote>
<p>handle()的使用效果与thenApply()类似，但不同的是thenApply()只能处理任务的正常返回结果，一旦出现异常则 无法进行后续处理。而handle()即可以处理正常结果，也可以处理异常结果。</p>
<p>当第一个任务出现异常后，第二个任务会对该异常进行后续的处理，完成串性操作。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162616742.png" srcset="/img/loading.gif" lazyload alt="image-20201003162616742"></p>
<h4 id="7-2-3-3-thenAccept"><a href="#7-2-3-3-thenAccept" class="headerlink" title="7.2.3.3 thenAccept()"></a>7.2.3.3 <strong>thenAccept()</strong></h4><blockquote>
<p>当将多个任务连接起来执行时，有时最终是不需要返回结果，CompletableFuture中也提供了方法实现。 thenAccept()使用与上述方法类似，接收任务执行结果，并使用，但其没有结果返回。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162744285.png" srcset="/img/loading.gif" lazyload alt="image-20201003162744285"></p>
<h4 id="7-2-3-4-thenRun"><a href="#7-2-3-4-thenRun" class="headerlink" title="7.2.3.4  thenRun()"></a>7.2.3.4  <strong>thenRun()</strong></h4><blockquote>
<p>thenRun()与thenAccept()使用基本相同，都是不会进行结果返回，但不同的是，thenRun()不关心方法是否有结 果，只要它完成，就会触发其执行。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162822708.png" srcset="/img/loading.gif" lazyload alt="image-20201003162822708"></p>
<h3 id="7-2-4-两任务合并执行"><a href="#7-2-4-两任务合并执行" class="headerlink" title="7.2.4 两任务合并执行"></a>7.2.4 两任务合并执行</h3><h4 id="7-2-4-1-两个任务全部完成触发"><a href="#7-2-4-1-两个任务全部完成触发" class="headerlink" title="7.2.4.1 两个任务全部完成触发"></a>7.2.4.1 两个任务全部完成触发</h4><h5 id="7-2-4-1-1-thenCombine"><a href="#7-2-4-1-1-thenCombine" class="headerlink" title="7.2.4.1.1 thenCombine()"></a>7.2.4.1.1 <strong>thenCombine()</strong></h5><blockquote>
<p>当两个异步任务都执行完毕后，它可以将两个任务进行合并，获取到两个任务的执行结果，进行合并处理，最后会有返回值。 </p>
<p>内部会判断当前要执行的函数是否为null，或者任务有没有执行完。如果为true，则抛出空指针异常。接着会构建 一个新的任务，将任务放入栈中，线程池会为其分配线程让其执行。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163113414.png" srcset="/img/loading.gif" lazyload alt="image-20201003163113414"></p>
<h5 id="7-2-4-1-2-thenAcceptBoth"><a href="#7-2-4-1-2-thenAcceptBoth" class="headerlink" title="7.2.4.1.2 thenAcceptBoth()"></a>7.2.4.1.2 <strong>thenAcceptBoth()</strong></h5><blockquote>
<p>thenAcceptBoth()使用与thenCombine()类似，当两个任务执行完，获取两个任务的结果进行特定处理，但 thenAcceptBoth()没有返回值 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163229028.png" srcset="/img/loading.gif" lazyload alt="image-20201003163229028"></p>
<h5 id="7-2-4-1-3-runAfterBoth"><a href="#7-2-4-1-3-runAfterBoth" class="headerlink" title="7.2.4.1.3 runAfterBoth()"></a>7.2.4.1.3 <strong>runAfterBoth()</strong></h5><blockquote>
<p>当两个任务执行完毕，触发特定任务处理，但不要两个异步任务结果，且不会进行值返回。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163318219.png" srcset="/img/loading.gif" lazyload alt="image-20201003163318219"></p>
<h4 id="7-2-4-2-两个任务任意一个完成触发"><a href="#7-2-4-2-两个任务任意一个完成触发" class="headerlink" title="7.2.4.2 两个任务任意一个完成触发"></a>7.2.4.2 两个任务任意一个完成触发</h4><h5 id="7-2-4-2-1-applyToEither"><a href="#7-2-4-2-1-applyToEither" class="headerlink" title="7.2.4.2.1 applyToEither()"></a>7.2.4.2.1 <strong>applyToEither()</strong></h5><blockquote>
<p>当两个任务异步任务执行，谁先执行完，就以谁的结果为准，完成后续的业务处理，并且会进行结果值返回。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163436119.png" srcset="/img/loading.gif" lazyload alt="image-20201003163436119"></p>
<h5 id="7-2-4-2-2-acceptEither"><a href="#7-2-4-2-2-acceptEither" class="headerlink" title="7.2.4.2.2 acceptEither()"></a>7.2.4.2.2 <strong>acceptEither()</strong></h5><blockquote>
<p>acceptEither()的使用效果与applyToEither()类似，但acceptEither()没有返回值</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163527665.png" srcset="/img/loading.gif" lazyload alt="image-20201003163527665"></p>
<h5 id="7-2-4-2-3-runAfterEither"><a href="#7-2-4-2-3-runAfterEither" class="headerlink" title="7.2.4.2.3 runAfterEither()"></a>7.2.4.2.3 <strong>runAfterEither()</strong></h5><blockquote>
<p>当两个任务执行，只要有一个任务执行完，则触发特定处理执行，无需使用异步任务的执行结果，且特定处理不会进行值的返回。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163634259.png" srcset="/img/loading.gif" lazyload alt="image-20201003163634259"></p>
<h3 id="7-2-5-多任务组合执行"><a href="#7-2-5-多任务组合执行" class="headerlink" title="7.2.5 多任务组合执行"></a>7.2.5 多任务组合执行</h3><h4 id="7-2-5-1-allOf"><a href="#7-2-5-1-allOf" class="headerlink" title="7.2.5.1 allOf()"></a>7.2.5.1 <strong>allOf()</strong></h4><blockquote>
<p>当一个特定业务处理任务的执行需要一组异步任务完成后才能执行的话，就可以通过allOf()实现。适用场景：假设现在有一个Z任务，它的执行需要[A,B,C,D,E,F]这一组异步任务全部执行完才能触发。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163858821.png" srcset="/img/loading.gif" lazyload alt="image-20201003163858821"></p>
<h4 id="7-2-5-2-）anyOf"><a href="#7-2-5-2-）anyOf" class="headerlink" title="7.2.5.2 ）anyOf()"></a>7.2.5.2 ）<strong>anyOf()</strong></h4><blockquote>
<p>使用anyOf()时，当一组异步任务中，只要有一个执行完毕，则会被触发，利用该特性可以用来获取最快的那个线程结果。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003164020818.png" srcset="/img/loading.gif" lazyload alt="image-20201003164020818">-<br>    System.out.println(“student存在”);<br>  }else {<br>    System.out.println(“student不存在”);<br>  }<br>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>  <br><br>- **ifPresent()**方法在执行时，接收一个consumer函数式接口，如果<span class="hljs-keyword">value</span>不为<span class="hljs-keyword">null</span>，则通过consumer中的 <br><br>  accept方法获取该值。 <br><br>  ```java<br>  Optional&lt;Student&gt; studentOptional = Optional.ofNullable(student); studentOptional.ifPresent(s‐&gt; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;学生存在&quot;));<br></code></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>get()</strong></p>
<blockquote>
<p>get()的使用非常简单，但不安全，因为其在获取值的时候，如果值存在，则直接返回封装在Optional中的值，如 果不存在，则抛出NoSuchElementException。因此它的使用前提是已经确定Optional中有值，否则没有使用意义。</p>
</blockquote>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (studentOptional.isPresent())&#123; <br>	<span class="hljs-type">Student</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> studentOptional.get(); <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>orElseThrow()</strong></li>
</ul>
<blockquote>
<p>该方法与get()类似，都是用于取值，但是当Optional中没有值时，get()会直接抛出NoSuchElementException， 这样的话，就存在了一定的局限性，因为有时可能需要抛出自定义异常。此时就可以使用orElseThrow()，它在取值时，如果Optional中没有值时，可以抛出自定义异常。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003165624398.png" srcset="/img/loading.gif" lazyload alt="image-20201003165624398"></p>
<ul>
<li><strong>map()</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (studentOptional.isPresent())&#123;<br>		Optional&lt;String&gt; nameOptional = studentOptional.map(Student::getName);<br>	&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>flflatMap()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Student类添加Job属性 </span><br><span class="hljs-keyword">private</span> Optional&lt;Job&gt; job; <br><span class="hljs-comment">//Job类添加Company属性 </span><br><span class="hljs-keyword">private</span> Optional&lt;ComPany&gt; comPany;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>用于多层调用</strong>，同时对于结 果它不会形成多个Optional，而是将结果处理成最终的一个类型的Optional。但是通过flflatMap获取的返回值必须是Optional类型。而map则没有这个限制。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; nameOptional = studentOptional.flatMap(Student::getJob).flatMap(Job::getCompany).map(Company::getName);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>fifilter()</strong></li>
</ul>
<blockquote>
<p>会根据传入的条件进行判断，如果匹配则返回一个Optional对象并包含对应的值，否则返回一个空值的Optional </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Company&gt; company = companyOptional.filter(c ‐&gt; <span class="hljs-string">&quot;itheima&quot;</span>.equals(c.getName()));<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>orElse()</strong></li>
</ul>
<blockquote>
<p>在取值的时候，如果值不存在，有时我们会考虑返回一个默认值。该需求就可以通过orElse()实现。 其内部会判断值是否为null，如果不为null，则返回该值，如果为null，则返回传入的默认值。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003170351987.png" srcset="/img/loading.gif" lazyload alt="image-20201003170351987"></p>
<ul>
<li><strong>orElseGet()</strong></li>
</ul>
<blockquote>
<p>orElseGet()也是用于当Optional中没有值时，返回默认值的方法。但是它与orElse()的区别在于，它是延迟加载 的。只有当Optional中没有值是才会被调用。</p>
<p><strong>在使用时，更加推荐使用orElseGet()，因为它使用延迟调用所以性能更加优异。</strong> </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003170559116.png" srcset="/img/loading.gif" lazyload alt="image-20201003170559116"></p>
<h1 id="9-日期时间新方式"><a href="#9-日期时间新方式" class="headerlink" title="9.日期时间新方式"></a>9.日期时间新方式</h1><blockquote>
<p><code>SimpleDateFormat</code>本身是线程不安全的，在多线程环境下，如果多个线程使用同一个类解析日期，最后的结果是 无法预期的。同时继承了它的<code>DateFormat</code>类也不是线程安全的。 </p>
<p><strong><code>DateTimeFormatter</code></strong> 该类是不可变和线程的。该类中提供了很多方法用于替换<code>SimpleDateFormat</code>。基于<code>DateTimeFormatter</code>改造</p>
</blockquote>
<ul>
<li><strong><code>LocalDate</code></strong> 根据源码可知，该类是一个不可变，线程安全的类。其内部了提供了若干用于操作日期的方法</li>
<li>**<code>LocalTime</code>**LocalTime类可以用来操作时间</li>
<li><strong><code>LocalDateTime</code></strong> LocalDateTime类可以用来操作日期+时间。</li>
</ul>
<h1 id="10-jdk11新特性"><a href="#10-jdk11新特性" class="headerlink" title="10.jdk11新特性"></a>10.jdk11新特性</h1><h2 id="1）变量类型推断"><a href="#1）变量类型推断" class="headerlink" title="1）变量类型推断"></a>1）变量类型推断</h2><p>在<code>JS</code>中，不管类型是什么，我们都是使用<code>var</code>来进行变量声明的。但是之前对于<code>Java</code>的使用，都会提到它是强类型语言，变量声明需要定义特定类型。但是在<code>JDK11</code>中对<code>JDK8</code>的类型推断思路又得以延伸，使用<code>JS</code>的方式，通过<code>var</code>定义局部变量，它会根据右边的表达式推断变量类型 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello itheima&quot;</span>; <br>sout(text);<br></code></pre></td></tr></table></figure>

<h2 id="2）新增字符串方法"><a href="#2）新增字符串方法" class="headerlink" title="2）新增字符串方法"></a>2）新增字符串方法</h2><p>在 JDK 11 中，新增了一些字符串方法，让字符串处理更加方便。其中包括：</p>
<ol>
<li><code>String.repeat(int)</code>：可以重复指定次数的字符串。</li>
<li><code>String.lines()</code>：方便地按行分割字符串。</li>
<li><code>String.strip()</code>：去除字符串首尾空白。</li>
<li><code>String.stripLeading()</code>：去除字符串开头的空白。</li>
<li><code>String.stripTrailing()</code>：去除字符串末尾的空白。</li>
<li><code>String.isBlank()</code>：判断字符串是否为空白。</li>
</ol>
<h2 id="3）新增创建集合的方式"><a href="#3）新增创建集合的方式" class="headerlink" title="3）新增创建集合的方式"></a>3）新增创建集合的方式</h2><p><code>JDK11</code>提供了通过<code>of()</code>和<code>copyOf()</code>创建集合的方式，但是创建的集合长度不可变，不能进行任何修改操作.</p>
<p><code>of()</code>会直接创建，而<code>copyOf()</code>首先会判断传入的集合是否为不可变集合，是的话直接返回，不是的话，调用<code>of()</code>创建新集合并返回。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> List.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;itheima&quot;</span>); <br><span class="hljs-type">var</span> <span class="hljs-variable">arrayList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(); <br><span class="hljs-type">var</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> List.copyOf(arrayList); <br></code></pre></td></tr></table></figure>

<h2 id="4）Files类增强"><a href="#4）Files类增强" class="headerlink" title="4）Files类增强"></a>4）Files类增强</h2><p>在<code>Files</code>类中新增两个方法：<code>writeString</code>和<code>readString</code>。可以把<code>String</code>内容写入文件或者把整个文件以<code>String</code>读出 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Files.writeString( Path.of(<span class="hljs-string">&quot;./&quot;</span>, <span class="hljs-string">&quot;demo.txt&quot;</span>), <span class="hljs-string">&quot;hello,itheima&quot;</span>, <span class="hljs-string">&quot;utf‐8&quot;</span>); <br><br><span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> Files.readString(Paths.get(<span class="hljs-string">&quot;./demo.txt&quot;</span>), <span class="hljs-string">&quot;utf‐8&quot;</span>); <br></code></pre></td></tr></table></figure>



<h2 id="5）HTTP-Client-Api"><a href="#5）HTTP-Client-Api" class="headerlink" title="5）HTTP Client Api"></a>5）HTTP Client Api</h2><p>平时我们要去访问<code>HTTP</code>资源，大多数时间我们都是通过第三方完成的，虽然在<code>JDK</code>标准类库中有<code>HttpURLConnection</code>，但是也不太好用。 在<code>JDK9</code>就提出了<code>HTTP Client Api</code>，经过9，10两个版本的改进，在11中正式发布。其同时支持同步请求和异步请 求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> HttpRequest.newBuilder()<br>.uri(URI.create(<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span>)) <br>.POST() <br>.build(); <br><span class="hljs-type">var</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> HttpClient.newHttpClient(); <br><span class="hljs-comment">// 同步 </span><br>HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); <br><span class="hljs-comment">// 异步 </span><br>client.sendAsync(request, HttpResponse.BodyHandlers.ofString()) <br>.thenApply(HttpResponse::body) <br>.thenAccept(System.out::println);<br></code></pre></td></tr></table></figure>

<h2 id="6）更方便的编译运行"><a href="#6）更方便的编译运行" class="headerlink" title="6）更方便的编译运行"></a>6）更方便的编译运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">之前</span> <br>javac Demo.java <br>java Demo <br><span class="hljs-meta prompt_">#</span><span class="language-bash">现在</span> <br>java Demo.java <br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/java/" class="category-chain-item">java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/" class="print-no-link">#java</a>
      
        <a href="/tags/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/" class="print-no-link">#jdk8新特性</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>jdk8以上提高开发效率的新特性有哪些</div>
      <div>http://www.lifeab.com/2024/04/08/jdk8提高开发效率的新特性有哪些/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Wick</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/04/09/IO%E5%8C%85%E4%B8%AD%E7%9A%84%E7%B1%BB/" title="java.io 包下的类">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">java.io 包下的类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/04/08/git/" title="git">
                        <span class="hidden-mobile">git</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'blydd/hexo');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo够优秀</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid主题够帅气</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
