title: 接口和抽象类
date: 2024-4-8 10:10:17
categories: java
toc: true
description: 接口和抽象类
tags: 
	- java
	- 接口
	- 抽象类

---


# 1. 抽象类
## **什么是抽象类:**

​		 包含一个抽象方法的类就是抽象类

##  **什么是抽象方法:**

 		声明而未被实现的方法，抽象方法必须使用`abstract`关键词字声明

```java
public abstract class People {  //关键词abstract，声明该类为抽象类
		public int age;
		public void Num() {
    }
    public abstract Name(); //声明该方法为抽象方法
	}
```
- **抽象类被子类继承，子类（如果不是抽象类）必须重写抽象类中的所有抽象方法**
- **抽象类不能被直接实例化，要通过其子类进行实例化** 
- 只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。
- 子类中的抽象方法不能与父类的抽象方法同名。
- `abstract`不能与`final`并列修饰同一个类。
- `abstract`不能与`private`、`static`、`final`或`native`并列修饰同一个方法。

##  为什么需要用到抽象类？
> 在下面这个例子中，把打印机类封装成抽象类，把`print`定义成抽象方法，当`HPPrinter`和`CannonPrinter`要继承`Printer`类的时候，必须重写`print`方法。
这样写的好处是，**每个打印机都有自己打印方式，此举可以防止子类没有写明打印方式。**

```java
//打印机抽象类
public abstract void Printer() {
    public void open() {
        system.out.print("打印机开启");
    }
    public void close() {
        system.out.print("打印机关闭");
    }
    //把print方法定义为抽象方法
    abstract void print();  
}
//惠普打印机
public HPPrinter extends Printer {
    void print(){             //必须重写抽象方法print()   
        system.out.print("惠普打印机开始打印");
    };
}
//佳能打印机
public CanonPrinter extends Printer {
    void print(){             //必须重写抽象方法print()
        system.out.print("佳能打印机开始打印");
    };
}
```
# 2. 接口
## **JDK8之前:**

​	**接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法组成,接口中所有方法都是抽象方法.接口当中所有的方法都是public类型.**

## **JDK8新特性:**

1. **引入默认方法和静态方法**。

   在 `JDK 8` 之前，接口只能包含抽象方法和静态常量。

   **这个变化的原因在于，如果接口新增抽象方法，那么所有实现类都必须实现这个新方法，不利于接口的扩展。**通过引入默认方法，可以在不破坏二进制兼容性的前提下向现有接口添加新方法，而不需要所有实现类都实现这个新方法。

   **默认方法和静态方法都可以有自己的方法体,当然默认方法也可以被重写.**

   **可以同时有多个默认方法 或 多个静态方法**

   静态方法也是非抽象方法，有自己的方法体，在接口中定义静态方法可以直接用 `接口名.方法名()` 的形式来调用。和调用类的静态方法一样

   ```java
   public interface IBird {
        //抽象方法eat,子类须重写
        void eat();
     
        //默认方法1 sing,子类选择性重写
        default String sing(String song){
           System.out.println("sing a song :" + song);
           return "sing a song :" + song;
        }
     
        //默认方法2 fly,子类选择性重写
        default void fly(){
         	System.out.println("fly");
        }
     
        //静态方法,直接调用,无法重写
        static void layEgg(){
         	System.out.println("下蛋");
        }
   
   }
   ```

   

2. **引入函数式接口**。

   **<u>函数式接口是指只包含一个抽象方法的接口</u>**，可以通过 `Lambda` 表达式来创建该接口的对象。

   **在 `JDK 8` 中，所有函数式接口都可以通过 `Lambda` 表达式进行实例化。**

## **接口的格式:**

```java
interface interfaceName{
    全局常量
    抽象方法
}
```
接口的实现也必须通过子类，使用关键字implements，而且接口是可以多实现的
```java
class A implements Inter1,Inter2{ //Inter1和Inter2是接口
    ...
}
```
一个类可以同时继承抽象类和接口
```java
class A extends Abs implements Inter1,Inter2{ //Abs是一个抽象类
    ...
}
```
一个接口不能继承抽象类，但可以通过implements关键字继承多个接口，实现接口的多继承
```java
interface Inter implements Inter1,Inter2{ //Inter、Inter1、Inter2都为接口
    ...
}
```
# 3. 抽象类和接口区别
## 3.1 语法层次

​	抽象类用`abstract`关键字修饰类为抽象类,接口`Interface`;

**语法规范:**

1. 接口不能有构造方法，抽象类可以有。
2. 接口不能有方法体，抽象类可以有。
3. 接口不能有静态方法，抽象类可以有。
4. 在接口中凡是变量必须是`public static final`(只能是常量)，而在抽象类中没有要求。
5. 抽象类可以定义非抽象方法，而接口中所有的方法都是抽象的  	



```java
public abstract class People {  //关键词abstract，声明该类为抽象类
    void Num();　　　　　　
    abstract void Name(); 　　　//声明该方法为抽象方法
}

Interface Person {
　　void Num();
　　void Name();
}　
```

抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，
但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。

在某种程度上来说，接口是抽象类的特殊化。
对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。

## 3.2 设计层次
### 1. 抽象层次不同
**抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。**

### 2. 跨域不同
抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。

我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，
但是接口不同。实现它的子类可以不存在任何关系或共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！

所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is-a" 关系，即父类和派生类在概念本质上应该是相同的。

对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。

### 3. 设计层次不同
对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。

比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！

但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

# 4.相同点:

1. 都不能被实例化,只能通过子类实例化.

2. 都可以被继承.
3. 都可以实现程序的多态性.












链接：

https://www.jianshu.com/p/b0cf5d770a86
https://blog.csdn.net/weixin_39788493/article/details/80854547
https://learn.skyofit.com/archives/303